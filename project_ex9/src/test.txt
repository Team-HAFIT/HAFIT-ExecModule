import React, { useEffect, useRef } from 'react';
import * as tf from '@tensorflow/tfjs';
import * as poseDetection from '@tensorflow-models/pose-detection';
import '@tensorflow/tfjs-backend-webgl';
import './style.css';

function Movenet() {
  const videoRef = useRef(null);
  const canvasRef = useRef(null);
  const hurrycheckRef = useRef(0);

  useEffect(() => {
    const loadPoseDetection = async () => {
      await tf.ready();
      const detectorConfig = {
        modelType: poseDetection.movenet.modelType.SINGLEPOSE_THUNDER,
        enableSmoothing: true,
        enableSegmentation: false,
      };
      const detector = await poseDetection.createDetector(
        poseDetection.SupportedModels.MoveNet,
        detectorConfig
      );

      let video = videoRef.current;
      let canvas = canvasRef.current;
      let ctx = canvas.getContext('2d');

      const camera = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: false,
      });
      video.srcObject = camera;

      // Add an event listener for the 'loadeddata' event
      video.addEventListener('loadeddata', () => {
        video.play();
      });

      const onLoadedMetadata = () => {
        // Start detecting poses once the video dimensions are set.
        detectPose();
      };
      video.addEventListener('loadedmetadata', onLoadedMetadata);

      let edges = {
        '5,7': 'm',
        '7,9': 'm',
        '6,8': 'c',
        '8,10': 'c',
        '5,17': 'y',
        '6,17':'m',
        '11,12': 'y',
        '11,13': 'm',
        '13,15': 'm',
        '12,14': 'c',
        '14,16': 'c',
        '17,18': 'c',
        '18,19': 'c',
        '19,20': 'c',
      };

      let hurry_check_edges = {
        '5,7': 'm',
        '5,17': 'm',
        '6,17': 'm',
        '7,9': 'm',
        '6,8': 'm',
        '8,10': 'm',
        '11,13': 'm',
        '13,15': 'm',
        '12,14': 'm',
        '14,16': 'm',
        '12,20': 'm',
        '11,20': 'm',
      }
      
      let hurry_error_edges = {
        '17,18': 'm',
        '18,19': 'm',
        '19,20': 'm'
      }

      let confidenceThreshold = 0.5;
      let hurryAngleThreshold = 15;             // 허리 각도 범위

      const drawResult = (pose) => {
        ctx.clearRect(0, 0, video.width, video.height);
        
        // Draw keypoints and skeleton on the canvas
        drawKeypoints(ctx, pose.keypoints);
        drawSkeleton(ctx, pose.keypoints, edges, confidenceThreshold);
        
      };
      const calculateAngle = (p1, p2, p3) => {
        let dx1 = p1.x - p2.x;
        let dy1 = p1.y - p2.y;
        let dx2 = p3.x - p2.x;
        let dy2 = p3.y - p2.y;
      
        // compute the dot product
        let dot = dx1 * dx2 + dy1 * dy2;
      
        // compute the magnitudes
        let mag1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
        let mag2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
      
        // use the dot product formula to find the angle
        let angle = Math.acos(dot / (mag1 * mag2));
      
        // return the angle in degrees
        return angle * (180.0 / Math.PI);
      };
      
      const detectPose = async () => {
        const poses = await detector.estimatePoses(video, {
          flipHorizontal: true,
        });
        if (poses.length > 0) {
          let leftShoulder = poses[0].keypoints[5];
          let rightShoulder = poses[0].keypoints[6];
          let leftHip = poses[0].keypoints[11];
          let rightHip = poses[0].keypoints[12];
          let leftKnee = poses[0].keypoints[13];
          let rightKnee = poses[0].keypoints[14];
          let leftAnkle = poses[0].keypoints[15];
          let rightAnkle = poses[0].keypoints[16];

          let leftKneeAngle = calculateAngle(leftHip, leftKnee, leftAnkle);
          let rightKneeAngle = calculateAngle(rightHip, rightKnee, rightAnkle);

      
          if (leftHip.score > confidenceThreshold && leftKnee.score > confidenceThreshold && leftAnkle.score > confidenceThreshold && 
              rightHip.score > confidenceThreshold && rightKnee.score > confidenceThreshold && rightAnkle.score > confidenceThreshold) {
              console.log(`Left knee angle: ${leftKneeAngle.toFixed(2)} degrees`);
              console.log(`Right knee angle: ${rightKneeAngle.toFixed(2)} degrees`);
          }

          
          let midShoulderX = (leftShoulder.x + rightShoulder.x) / 2;
          let midShoulderY = (leftShoulder.y + rightShoulder.y) / 2;
          let midHipX = (leftHip.x + rightHip.x) / 2;
          let midHipY = (leftHip.y + rightHip.y) / 2;
      
          let middleShoulder = { x: midShoulderX, y: midShoulderY, score: Math.min(leftShoulder.score, rightShoulder.score) };
          poses[0].keypoints[17] = { x: midShoulderX, y: midShoulderY, score: Math.min(leftShoulder.score, rightShoulder.score) };
          
          let midhip = { x: midHipX, y: midHipY, score: Math.min(leftHip.score, rightHip.score) };
          poses[0].keypoints[20] = { x: midHipX, y: midHipY, score: Math.min(leftHip.score, rightHip.score) };

          const x1 = middleShoulder.x;
          const y1 = middleShoulder.y;
          const x2 = poses[0].keypoints[20].x;
          const y2 = poses[0].keypoints[20].y;
      
          const x1_3 = (2 * x1 + x2) / 3;
          const y1_3 = (2 * y1 + y2) / 3;
          const x2_3 = (x1 + 2 * x2) / 3;
          const y2_3 = (y1 + 2 * y2) / 3;
      
          poses[0].keypoints[18] = { x: x1_3, y: y1_3, score: Math.min(leftShoulder.score, rightShoulder.score) };
          poses[0].keypoints[19] = { x: x2_3, y: y2_3, score: Math.min(leftHip.score, rightHip.score) };
          
          let hurrycheckpoint = {x: midHipX, y: midShoulderY, score: Math.min(midhip.score, middleShoulder.score) };
          hurrycheckRef.current = calculateAngle(middleShoulder, midhip, hurrycheckpoint);
          console.log(`hurrycheck: ${hurrycheckRef.current.toFixed(2)} degrees`);
          drawResult(poses[0]);
        }
        requestAnimationFrame(detectPose);
      };
      
      const drawKeypoints = (ctx, keypoints) => {
        const canvas = canvasRef.current;
        const video = videoRef.current;
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;
        const originalWidth = video.videoWidth;
        const originalHeight = video.videoHeight;
        const scaleX = canvasWidth / originalWidth;
        const scaleY = canvasHeight / originalHeight;
      
        ctx.strokeStyle = 'rgb(0, 0, 255)';
        ctx.fillStyle = 'transparent';
        ctx.lineWidth = 2;
        ctx.font = '12px Arial';
      
        for (const kp of keypoints) {
          const { x, y, score } = kp;
          if (score > 0.3) {
            const adjustedX = video.width - x * scaleX;
            const adjustedY = y * scaleY;
      
            ctx.beginPath();
            ctx.arc(adjustedX, adjustedY, 6, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
      
            ctx.fillStyle = 'red';
            ctx.fillText(`(${adjustedX.toFixed(0)}, ${adjustedY.toFixed(0)})`, adjustedX - 20, adjustedY - 10);
            ctx.fillStyle = 'white';
          }
        }
      };
      
      const drawSkeleton = (ctx, keypoints, edges, confidenceThreshold) => {
        const canvas = canvasRef.current;
        const video = videoRef.current;
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;
        const originalWidth = video.videoWidth;
        const originalHeight = video.videoHeight;
        const scaleX = canvasWidth / originalWidth;
        const scaleY = canvasHeight / originalHeight;
        
        if( hurrycheck > hurryAngleThreshold){
          for (const [key] of Object.entries(hurry_check_edges)) {
            const [p1, p2] = key.split(',');
            const kp1 = keypoints[p1];
            const kp2 = keypoints[p2];
        
            const y1 = kp1.y * scaleY;
            const x1 = video.width - kp1.x * scaleX;
            const c1 = kp1.score;
            const y2 = kp2.y * scaleY;
            const x2 = video.width - kp2.x * scaleX;
            const c2 = kp2.score;
            
            if (c1 > confidenceThreshold && c2 > confidenceThreshold) {
              ctx.strokeStyle = 'rgb(255, 0, 0)';
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.moveTo(x1, y1);
              ctx.lineTo(x2, y2);
              ctx.stroke();
            }
          }
          for (const [key] of Object.entries(hurry_error_edges)) {
            const [p1, p2] = key.split(',');
            const kp1 = keypoints[p1];
            const kp2 = keypoints[p2];
        
            const y1 = kp1.y * scaleY;
            const x1 = video.width - kp1.x * scaleX;
            const c1 = kp1.score;
            const y2 = kp2.y * scaleY;
            const x2 = video.width - kp2.x * scaleX;
            const c2 = kp2.score;
            
            if (c1 > confidenceThreshold && c2 > confidenceThreshold) {
              ctx.strokeStyle = 'rgb(255, 0, 0)';
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.moveTo(x1, y1);
              ctx.lineTo(x2, y2);
              ctx.stroke();
            }
          }
        }else{
          for (const [key] of Object.entries(edges)) {
            const [p1, p2] = key.split(',');
            const kp1 = keypoints[p1];
            const kp2 = keypoints[p2];
        
            const y1 = kp1.y * scaleY;
            const x1 = video.width - kp1.x * scaleX;
            const c1 = kp1.score;
            const y2 = kp2.y * scaleY;
            const x2 = video.width - kp2.x * scaleX;
            const c2 = kp2.score;
            
            if (c1 > confidenceThreshold && c2 > confidenceThreshold) {
              ctx.strokeStyle = 'rgb(0, 255, 0)';
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.moveTo(x1, y1);
              ctx.lineTo(x2, y2);
              ctx.stroke();
            }
          }
        } 
      };
    };

    loadPoseDetection();
  }, []);

  return (
    <div className="container">
      <video width="800" height="600" ref={videoRef} className="input_video" style={{ transform: 'scaleX(-1)' }}></video>
      <canvas width="800" height="600" ref={canvasRef} className="output_canvas"></canvas>
    </div>
  );
}

export default Movenet;
